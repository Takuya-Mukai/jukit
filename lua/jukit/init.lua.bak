local M = {}

-- === 設定 ===
local default_config = {
    preview_width_percent = 40,
    repl_height_percent = 30,
    preview_image_ratio = 0.6,
    repl_image_ratio = 0.3,
    flash_highlight_group = "Visual",
    flash_duration = 300,
    python_interpreter = "python3", 
}
M.config = vim.deepcopy(default_config)

local job_id = nil
local output_buf = nil
local output_win = nil
local preview_win = nil
local hl_ns = vim.api.nvim_create_namespace("JukitCellHighlight")
local current_preview_file = nil

-- === ユーティリティ ===

local function generate_id()
    math.randomseed(os.time())
    local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"
    local id = ""
    for i = 1, 8 do
        local rand = math.random(#chars)
        id = id .. string.sub(chars, rand, rand)
    end
    return id
end

local function ensure_cell_id(line_num, line_content)
    local id = line_content:match("id=\"([%w%-_]+)\"")
    if id then return id end
    id = generate_id()
    if line_content:match("^# %%%%") then
        local new_line = line_content .. " id=\"" .. id .. "\""
        vim.api.nvim_buf_set_lines(0, line_num - 1, line_num, false, {new_line})
    end
    return id
end

local function get_cell_id(line_num)
    local lnum = line_num or vim.fn.line(".")
    local lines = vim.api.nvim_buf_get_lines(0, lnum - 1, lnum, false)
    local line = lines[1] or ""
    local id = line:match("id=\"([%w%-_]+)\"")
    if id then return id end

    for l = lnum, 1, -1 do
        local l_content = vim.api.nvim_buf_get_lines(0, l - 1, l, false)[1]
        local mid = l_content:match("id=\"([%w%-_]+)\"")
        if mid then return mid end
        if l_content:match("^# %%%%") then break end
    end
    
    if line:match("^# %%%%") then
        local nid = generate_id()
        local new_line = line .. " id=\"" .. nid .. "\""
        vim.api.nvim_buf_set_lines(0, lnum - 1, lnum, false, {new_line})
        return nid
    end
    return "scratchpad"
end

local function flash_cell(start_line, end_line)
    vim.api.nvim_buf_clear_namespace(0, hl_ns, 0, -1)
    vim.api.nvim_buf_set_extmark(0, hl_ns, start_line - 1, 0, {
        end_row = end_line,
        hl_group = M.config.flash_highlight_group,
        hl_eol = true, priority = 200,
    })
    vim.defer_fn(function()
        if vim.api.nvim_buf_is_valid(0) then
            vim.api.nvim_buf_clear_namespace(0, hl_ns, 0, -1)
        end
    end, M.config.flash_duration)
end

function M.clean_stale_cache()
    if not job_id then return end
    local filename = vim.fn.expand("%:t")
    if filename == "" then return end
    local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
    local valid_ids = {}
    for _, line in ipairs(lines) do
        local id = line:match("id=\"([%w%-_]+)\"")
        if id then table.insert(valid_ids, id) end
    end
    local msg = vim.fn.json_encode({
        command = "clean_cache",
        filename = filename,
        valid_ids = valid_ids
    })
    vim.fn.chansend(job_id, msg .. "\n")
end

-- === REPL 出力 ===

local function append_to_repl(text, hl_group)
    if not (output_buf and vim.api.nvim_buf_is_valid(output_buf)) then return end
    local lines = type(text) == "table" and text or vim.split(text, "\n")
    vim.api.nvim_buf_set_lines(output_buf, -1, -1, false, lines)
    local last_line = vim.api.nvim_buf_line_count(output_buf)
    if hl_group then
        for i = 0, #lines - 1 do
            vim.api.nvim_buf_add_highlight(output_buf, -1, hl_group, last_line - #lines + i, 0, -1)
        end
    end
    if output_win and vim.api.nvim_win_is_valid(output_win) then
        vim.api.nvim_win_set_cursor(output_win, {last_line, 0})
    end
end

local function append_stream_text(text)
    if not (output_buf and vim.api.nvim_buf_is_valid(output_buf)) then return end
    if text:find("\r") then
        local parts = vim.split(text, "\r")
        local last_part = parts[#parts]
        local line_count = vim.api.nvim_buf_line_count(output_buf)
        vim.api.nvim_buf_set_lines(output_buf, line_count - 1, line_count, false, {last_part})
    else
        local lines = vim.split(text, "\n")
        if lines[#lines] == "" and #lines > 1 then table.remove(lines, #lines) end
        vim.api.nvim_buf_set_lines(output_buf, -1, -1, false, lines)
    end
    if output_win and vim.api.nvim_win_is_valid(output_win) then
        local count = vim.api.nvim_buf_line_count(output_buf)
        vim.api.nvim_win_set_cursor(output_win, {count, 0})
    end
end

-- === Preview (Markdown & 画像表示) ===

local function open_markdown_preview(filepath)
    if not (preview_win and vim.api.nvim_win_is_valid(preview_win)) then return end
    current_preview_file = filepath

    -- フォーカスをPreviewへ
    local cur_win = vim.api.nvim_get_current_win()
    vim.api.nvim_set_current_win(preview_win)
    
    -- 強制リロードで開く
    vim.cmd("edit! " .. filepath)
    
    -- ★ 設定: Markdownとして扱い、通常ファイル(buftype="")にする
    vim.bo.filetype = ""
    vim.bo.filetype = "markdown"
    vim.bo.buftype = "" 
    vim.wo.wrap = true
    
    vim.defer_fn(function()
        vim.api.nvim_exec_autocmds("WinResized", {})
        vim.cmd("redraw!")
    end, 50)


    -- 元のウィンドウに戻る
    if vim.api.nvim_win_is_valid(cur_win) then
        vim.api.nvim_set_current_win(cur_win)
    end
end

function M.check_cursor_cell()
    if not job_id then return end
    vim.schedule(function()
        local cell_id = get_cell_id()
        local filename = vim.fn.expand("%:t")
        if filename == "" then filename = "scratchpad" end
        
        local cache_dir = ".jukit_cache/" .. filename
        local md_path = cache_dir .. "/" .. cell_id .. ".md"
        
        -- ここで判定して開く
        if current_preview_file ~= md_path and vim.fn.filereadable(md_path) == 1 then
            open_markdown_preview(md_path)
        end
    end)
end

-- === ハンドラ ===

local function on_stdout(chan_id, data, name)
    if not data then return end
    for _, line in ipairs(data) do
        if line ~= "" then
            local ok, msg = pcall(vim.fn.json_decode, line)
            if ok and msg then
                vim.schedule(function()
                    if msg.type == "stream" then
                        append_stream_text(msg.text)
                    elseif msg.type == "image_saved" then
                        append_to_repl("[Image Created]: " .. vim.fn.fnamemodify(msg.path, ":t"), "Special")
                    elseif msg.type == "result_ready" then
                        append_to_repl("-> Done: " .. msg.cell_id, "Comment")
                        current_preview_file = nil 
                        open_markdown_preview(msg.file)
                    end
                end)
            end
        end
    end
end

-- === ウィンドウ管理 (フォーカス制御版) ===

local function get_or_create_buf(name)
    local existing = vim.fn.bufnr(name)
    if existing ~= -1 and vim.api.nvim_buf_is_valid(existing) then return existing end
    local buf = vim.api.nvim_create_buf(false, true)
    vim.api.nvim_buf_set_name(buf, name)
    vim.api.nvim_buf_set_option(buf, "buftype", "nofile")
    return buf
end

-- 引数 target_win: 開いた後に戻るべきウィンドウID
function M.open_windows(target_win)
    -- 何も指定がなければ現在のウィンドウを戻り先とする
    local return_to = target_win or vim.api.nvim_get_current_win()
    
    -- Preview
    if not (preview_win and vim.api.nvim_win_is_valid(preview_win)) then
        vim.cmd("vsplit")
        vim.cmd("wincmd L")
        preview_win = vim.api.nvim_get_current_win()
        
        local width = math.floor(vim.o.columns * (M.config.preview_width_percent / 100))
        vim.api.nvim_win_set_width(preview_win, width)
        
        -- Previewバッファは通常ファイル扱いにするため、ここでは空作成
        local pbuf = vim.api.nvim_create_buf(false, true)
        vim.api.nvim_win_set_buf(preview_win, pbuf)
    end
    
    -- REPL
    if not (output_win and vim.api.nvim_win_is_valid(output_win)) then
        -- 一旦戻り先（コード側）にフォーカスしてから分割することで、レイアウト崩れを防ぐ
        if vim.api.nvim_win_is_valid(return_to) then
            vim.api.nvim_set_current_win(return_to)
        end
        
        vim.cmd("split")
        vim.cmd("wincmd j")
        output_win = vim.api.nvim_get_current_win()
        output_buf = get_or_create_buf("JukitConsole")
        
        if vim.api.nvim_buf_line_count(output_buf) <= 1 then
            vim.api.nvim_buf_set_lines(output_buf, 0, -1, false, {"[Jukit Console Ready]"})
        end
        vim.api.nvim_win_set_buf(output_win, output_buf)
        
        local height = math.floor(vim.o.lines * (M.config.repl_height_percent / 100))
        vim.api.nvim_win_set_height(output_win, height)
    end
    
    -- ★ 最後に必ず指定されたウィンドウに戻る
    if vim.api.nvim_win_is_valid(return_to) then
        vim.api.nvim_set_current_win(return_to)
    end
end

function M.close_windows()
    if preview_win and vim.api.nvim_win_is_valid(preview_win) then vim.api.nvim_win_close(preview_win, true) end
    if output_win and vim.api.nvim_win_is_valid(output_win) then vim.api.nvim_win_close(output_win, true) end
    preview_win, output_win = nil, nil
    current_preview_file = nil
end

function M.toggle_windows()
    if (preview_win and vim.api.nvim_win_is_valid(preview_win)) or (output_win and vim.api.nvim_win_is_valid(output_win)) then
        M.close_windows()
    else
        M.open_windows()
    end
end

-- === 実行関数 ===

local function send_payload(code, cell_id, filename)
    if not job_id then M.start_kernel() end
    append_to_repl({"In [" .. cell_id .. "]:"}, "Type")
    local code_lines = vim.split(code, "\n")
    local indented = {}
    for _, l in ipairs(code_lines) do table.insert(indented, "    " .. l) end
    append_to_repl(indented)
    append_to_repl({""})

    local msg = vim.fn.json_encode({
        command = "execute", code = code, cell_id = cell_id, filename = filename
    })
    vim.fn.chansend(job_id, msg .. "\n")
end

function M.send_cell()
    -- 1. 実行元のウィンドウ（Pythonコード）を確保
    local src_win = vim.api.nvim_get_current_win()
    
    -- 2. ウィンドウを開く (引数に戻り先を渡す)
    M.open_windows(src_win)
    
    -- 3. 念には念を入れて、強制的に戻る
    vim.api.nvim_set_current_win(src_win)

    -- ここから下は `src_win` (Pythonファイル) がアクティブな状態で実行される
    local cursor = vim.api.nvim_win_get_cursor(0)[1]
    local total = vim.api.nvim_buf_line_count(0)
    local s, e = cursor, cursor
    while s > 1 do
        if vim.api.nvim_buf_get_lines(0, s-1, s, false)[1]:match("^# %%%%") then break end
        s = s - 1
    end
    while e < total do
        if vim.api.nvim_buf_get_lines(0, e, e+1, false)[1]:match("^# %%%%") then break end
        e = e + 1
    end
    flash_cell(s, e)
    local lines = vim.api.nvim_buf_get_lines(0, s-1, e, false)
    if #lines > 0 and lines[1]:match("^# %%%%") then table.remove(lines, 1) end
    local id = get_cell_id(s)
    local fn = vim.fn.expand("%:t")
    if fn == "" then fn = "untitled" end
    send_payload(table.concat(lines, "\n"), id, fn)
end

function M.send_selection()
    local src_win = vim.api.nvim_get_current_win()
    M.open_windows(src_win)
    vim.api.nvim_set_current_win(src_win)

    local _, csrow, _, _ = unpack(vim.fn.getpos("'<"))
    local _, cerow, _, _ = unpack(vim.fn.getpos("'>"))
    local lines = vim.api.nvim_buf_get_lines(0, csrow - 1, cerow, false)
    if #lines == 0 then return end
    flash_cell(csrow, cerow)
    local id = get_cell_id(csrow)
    local fn = vim.fn.expand("%:t")
    if fn == "" then fn = "untitled" end
    send_payload(table.concat(lines, "\n"), id, fn)
end

function M.run_all_cells()
    local src_win = vim.api.nvim_get_current_win()
    M.open_windows(src_win)
    vim.api.nvim_set_current_win(src_win)
    
    if not job_id then M.start_kernel() end
    local fn = vim.fn.expand("%:t")
    if fn == "" then fn = "untitled" end
    local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
    local blk, bid, is_code = {}, "scratchpad", true
    for i, line in ipairs(lines) do
        if line:match("^# %%%%") then
            if #blk > 0 and is_code then send_payload(table.concat(blk, "\n"), bid, fn) end
            blk, bid = {}, ensure_cell_id(i, line)
            is_code = not line:lower():match("^# %%%%+%s*%[markdown%]")
        else
            if is_code then table.insert(blk, line) end
        end
    end
    if #blk > 0 and is_code then send_payload(table.concat(blk, "\n"), bid, fn) end
end

-- === カーネル ===

function M.start_kernel()
    if job_id then return end
    local script = vim.fn.fnamemodify(debug.getinfo(1).source:sub(2), ":h:h:h") .. "/lua/jukit/kernel.py"
    local cmd = vim.split(M.config.python_interpreter, " ")
    table.insert(cmd, script)
    
    job_id = vim.fn.jobstart(cmd, {
        on_stdout = on_stdout,
        on_stderr = on_stdout,
        stdout_buffered = false,
        on_exit = function() job_id = nil end
    })
    append_to_repl("[Jukit Kernel Started]")
    vim.defer_fn(function() M.clean_stale_cache() end, 500)
end

function M.restart_kernel()
    if job_id then vim.fn.jobstop(job_id); job_id = nil end
    append_to_repl("[Kernel Restarting...]", "WarningMsg")
    M.start_kernel()
end

function M.setup(opts)
    M.config = vim.tbl_deep_extend("force", default_config, opts or {})
    vim.api.nvim_create_user_command("JukitStart", M.start_kernel, {})
    vim.api.nvim_create_user_command("JukitRun", M.send_cell, {})
    vim.api.nvim_create_user_command("JukitSendSelection", M.send_selection, { range = true })
    vim.api.nvim_create_user_command("JukitRunAll", M.run_all_cells, {})
    vim.api.nvim_create_user_command("JukitRestart", M.restart_kernel, {})
    vim.api.nvim_create_user_command("JukitOpen", M.open_windows, {})
    vim.api.nvim_create_user_command("JukitToggle", M.toggle_windows, {})
    vim.api.nvim_create_user_command("JukitClean", M.clean_stale_cache, {})
    
    vim.api.nvim_create_autocmd({"CursorHold", "CursorHoldI"}, {
        pattern = "*",
        callback = function() if vim.bo.filetype == "python" then M.check_cursor_cell() end end
    })
end

return M
